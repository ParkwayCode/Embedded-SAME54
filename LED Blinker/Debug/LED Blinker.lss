
LED Blinker.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000da0  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000000  20000000  20000000  00010da0  2**0
                  CONTENTS
  2 .bkupram      00000000  47000000  47000000  00010da0  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  00010da0  2**0
                  CONTENTS
  4 .bss          00000068  20000000  20000000  00020000  2**2
                  ALLOC
  5 .stack        00010000  20000068  20000068  00020000  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  00010da0  2**0
                  CONTENTS, READONLY
  7 .comment      00000059  00000000  00000000  00010dce  2**0
                  CONTENTS, READONLY
  8 .debug_info   0000de94  00000000  00000000  00010e27  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000024b0  00000000  00000000  0001ecbb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002169  00000000  00000000  0002116b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000408  00000000  00000000  000232d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000330  00000000  00000000  000236dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00030b53  00000000  00000000  00023a0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   0000e00c  00000000  00000000  0005455f  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0010fb5b  00000000  00000000  0006256b  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00000764  00000000  00000000  001720c8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
   0:	68 00 01 20 e1 02 00 00 dd 02 00 00 dd 02 00 00     h.. ............
  10:	dd 02 00 00 dd 02 00 00 dd 02 00 00 00 00 00 00     ................
	...
  2c:	dd 02 00 00 dd 02 00 00 00 00 00 00 dd 02 00 00     ................
  3c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  4c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  5c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  6c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  7c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  8c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  9c:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  ac:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  bc:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  cc:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
  dc:	dd 02 00 00 dd 02 00 00 dd 02 00 00 00 00 00 00     ................
	...
  f4:	75 08 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     u...............
 104:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 114:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 124:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 134:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 144:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 154:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 164:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 174:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 184:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 194:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 1a4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 1b4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 1c4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 1d4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 1e4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 b9 0b 00 00     ................
 1f4:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 204:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 214:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 224:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 234:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 244:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................
 254:	dd 02 00 00 dd 02 00 00 dd 02 00 00 dd 02 00 00     ................

00000264 <__do_global_dtors_aux>:
 264:	b510      	push	{r4, lr}
 266:	4c05      	ldr	r4, [pc, #20]	; (27c <__do_global_dtors_aux+0x18>)
 268:	7823      	ldrb	r3, [r4, #0]
 26a:	b933      	cbnz	r3, 27a <__do_global_dtors_aux+0x16>
 26c:	4b04      	ldr	r3, [pc, #16]	; (280 <__do_global_dtors_aux+0x1c>)
 26e:	b113      	cbz	r3, 276 <__do_global_dtors_aux+0x12>
 270:	4804      	ldr	r0, [pc, #16]	; (284 <__do_global_dtors_aux+0x20>)
 272:	f3af 8000 	nop.w
 276:	2301      	movs	r3, #1
 278:	7023      	strb	r3, [r4, #0]
 27a:	bd10      	pop	{r4, pc}
 27c:	20000000 	.word	0x20000000
 280:	00000000 	.word	0x00000000
 284:	00000da0 	.word	0x00000da0

00000288 <frame_dummy>:
 288:	4b0c      	ldr	r3, [pc, #48]	; (2bc <frame_dummy+0x34>)
 28a:	b143      	cbz	r3, 29e <frame_dummy+0x16>
 28c:	480c      	ldr	r0, [pc, #48]	; (2c0 <frame_dummy+0x38>)
 28e:	490d      	ldr	r1, [pc, #52]	; (2c4 <frame_dummy+0x3c>)
 290:	b510      	push	{r4, lr}
 292:	f3af 8000 	nop.w
 296:	480c      	ldr	r0, [pc, #48]	; (2c8 <frame_dummy+0x40>)
 298:	6803      	ldr	r3, [r0, #0]
 29a:	b923      	cbnz	r3, 2a6 <frame_dummy+0x1e>
 29c:	bd10      	pop	{r4, pc}
 29e:	480a      	ldr	r0, [pc, #40]	; (2c8 <frame_dummy+0x40>)
 2a0:	6803      	ldr	r3, [r0, #0]
 2a2:	b933      	cbnz	r3, 2b2 <frame_dummy+0x2a>
 2a4:	4770      	bx	lr
 2a6:	4b09      	ldr	r3, [pc, #36]	; (2cc <frame_dummy+0x44>)
 2a8:	2b00      	cmp	r3, #0
 2aa:	d0f7      	beq.n	29c <frame_dummy+0x14>
 2ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 2b0:	4718      	bx	r3
 2b2:	4b06      	ldr	r3, [pc, #24]	; (2cc <frame_dummy+0x44>)
 2b4:	2b00      	cmp	r3, #0
 2b6:	d0f5      	beq.n	2a4 <frame_dummy+0x1c>
 2b8:	4718      	bx	r3
 2ba:	bf00      	nop
 2bc:	00000000 	.word	0x00000000
 2c0:	00000da0 	.word	0x00000da0
 2c4:	20000004 	.word	0x20000004
 2c8:	00000da0 	.word	0x00000da0
 2cc:	00000000 	.word	0x00000000

000002d0 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
 2d0:	b508      	push	{r3, lr}
	system_init();
 2d2:	4b01      	ldr	r3, [pc, #4]	; (2d8 <atmel_start_init+0x8>)
 2d4:	4798      	blx	r3
 2d6:	bd08      	pop	{r3, pc}
 2d8:	000003ad 	.word	0x000003ad

000002dc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 2dc:	e7fe      	b.n	2dc <Dummy_Handler>
	...

000002e0 <Reset_Handler>:
{
 2e0:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
 2e2:	4b15      	ldr	r3, [pc, #84]	; (338 <Reset_Handler+0x58>)
 2e4:	4a15      	ldr	r2, [pc, #84]	; (33c <Reset_Handler+0x5c>)
 2e6:	429a      	cmp	r2, r3
 2e8:	d009      	beq.n	2fe <Reset_Handler+0x1e>
 2ea:	4b13      	ldr	r3, [pc, #76]	; (338 <Reset_Handler+0x58>)
 2ec:	4a13      	ldr	r2, [pc, #76]	; (33c <Reset_Handler+0x5c>)
 2ee:	e003      	b.n	2f8 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
 2f0:	6811      	ldr	r1, [r2, #0]
 2f2:	6019      	str	r1, [r3, #0]
 2f4:	3304      	adds	r3, #4
 2f6:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
 2f8:	4911      	ldr	r1, [pc, #68]	; (340 <Reset_Handler+0x60>)
 2fa:	428b      	cmp	r3, r1
 2fc:	d3f8      	bcc.n	2f0 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
 2fe:	4b11      	ldr	r3, [pc, #68]	; (344 <Reset_Handler+0x64>)
 300:	e002      	b.n	308 <Reset_Handler+0x28>
                *pDest++ = 0;
 302:	2200      	movs	r2, #0
 304:	601a      	str	r2, [r3, #0]
 306:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
 308:	4a0f      	ldr	r2, [pc, #60]	; (348 <Reset_Handler+0x68>)
 30a:	4293      	cmp	r3, r2
 30c:	d3f9      	bcc.n	302 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 30e:	4b0f      	ldr	r3, [pc, #60]	; (34c <Reset_Handler+0x6c>)
 310:	4a0f      	ldr	r2, [pc, #60]	; (350 <Reset_Handler+0x70>)
 312:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 316:	609a      	str	r2, [r3, #8]
        SCB->CPACR |=  (0xFu << 20);
 318:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 31c:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 320:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 324:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 328:	f3bf 8f6f 	isb	sy
        __libc_init_array();
 32c:	4b09      	ldr	r3, [pc, #36]	; (354 <Reset_Handler+0x74>)
 32e:	4798      	blx	r3
        main();
 330:	4b09      	ldr	r3, [pc, #36]	; (358 <Reset_Handler+0x78>)
 332:	4798      	blx	r3
 334:	e7fe      	b.n	334 <Reset_Handler+0x54>
 336:	bf00      	nop
 338:	20000000 	.word	0x20000000
 33c:	00000da0 	.word	0x00000da0
 340:	20000000 	.word	0x20000000
 344:	20000000 	.word	0x20000000
 348:	20000068 	.word	0x20000068
 34c:	e000ed00 	.word	0xe000ed00
 350:	00000000 	.word	0x00000000
 354:	00000cb9 	.word	0x00000cb9
 358:	00000c11 	.word	0x00000c11

0000035c <TIMER_0_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_0_init(void)
{
 35c:	b508      	push	{r3, lr}
}

static inline void hri_mclk_set_APBAMASK_TC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
 35e:	4a08      	ldr	r2, [pc, #32]	; (380 <TIMER_0_init+0x24>)
 360:	6953      	ldr	r3, [r2, #20]
 362:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 366:	6153      	str	r3, [r2, #20]
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
 368:	2240      	movs	r2, #64	; 0x40
 36a:	4b06      	ldr	r3, [pc, #24]	; (384 <TIMER_0_init+0x28>)
 36c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
	hri_mclk_set_APBAMASK_TC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, TC1_GCLK_ID, CONF_GCLK_TC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	timer_init(&TIMER_0, TC1, _tc_get_timer());
 370:	4b05      	ldr	r3, [pc, #20]	; (388 <TIMER_0_init+0x2c>)
 372:	4798      	blx	r3
 374:	4602      	mov	r2, r0
 376:	4905      	ldr	r1, [pc, #20]	; (38c <TIMER_0_init+0x30>)
 378:	4805      	ldr	r0, [pc, #20]	; (390 <TIMER_0_init+0x34>)
 37a:	4b06      	ldr	r3, [pc, #24]	; (394 <TIMER_0_init+0x38>)
 37c:	4798      	blx	r3
 37e:	bd08      	pop	{r3, pc}
 380:	40000800 	.word	0x40000800
 384:	40001c00 	.word	0x40001c00
 388:	00000b73 	.word	0x00000b73
 38c:	40003c00 	.word	0x40003c00
 390:	2000003c 	.word	0x2000003c
 394:	0000051d 	.word	0x0000051d

00000398 <delay_driver_init>:
{
 398:	b508      	push	{r3, lr}
	delay_init(SysTick);
 39a:	4802      	ldr	r0, [pc, #8]	; (3a4 <delay_driver_init+0xc>)
 39c:	4b02      	ldr	r3, [pc, #8]	; (3a8 <delay_driver_init+0x10>)
 39e:	4798      	blx	r3
 3a0:	bd08      	pop	{r3, pc}
 3a2:	bf00      	nop
 3a4:	e000e010 	.word	0xe000e010
 3a8:	00000451 	.word	0x00000451

000003ac <system_init>:
}

void system_init(void)
{
 3ac:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
 3ae:	4b1b      	ldr	r3, [pc, #108]	; (41c <system_init+0x70>)
 3b0:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
 3b2:	4b1b      	ldr	r3, [pc, #108]	; (420 <system_init+0x74>)
 3b4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 3b8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
 3bc:	4919      	ldr	r1, [pc, #100]	; (424 <system_init+0x78>)
 3be:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
 3c2:	f101 2180 	add.w	r1, r1, #2147516416	; 0x80008000
 3c6:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
 3ca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
 3ce:	f893 10df 	ldrb.w	r1, [r3, #223]	; 0xdf
 3d2:	f041 0104 	orr.w	r1, r1, #4
 3d6:	f883 10df 	strb.w	r1, [r3, #223]	; 0xdf
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
 3da:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 3de:	f893 20df 	ldrb.w	r2, [r3, #223]	; 0xdf
	tmp &= ~PORT_PINCFG_PMUXEN;
 3e2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 3e6:	f883 20df 	strb.w	r2, [r3, #223]	; 0xdf
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
 3ea:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 3ee:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
 3f2:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
 3f6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 3fa:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
 3fe:	4a0a      	ldr	r2, [pc, #40]	; (428 <system_init+0x7c>)
 400:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 404:	f893 2152 	ldrb.w	r2, [r3, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
 408:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 40c:	f883 2152 	strb.w	r2, [r3, #338]	; 0x152
	// Set pin direction to output
	gpio_set_pin_direction(LED_0, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED_0, GPIO_PIN_FUNCTION_OFF);

	delay_driver_init();
 410:	4b06      	ldr	r3, [pc, #24]	; (42c <system_init+0x80>)
 412:	4798      	blx	r3

	TIMER_0_init();
 414:	4b06      	ldr	r3, [pc, #24]	; (430 <system_init+0x84>)
 416:	4798      	blx	r3
 418:	bd08      	pop	{r3, pc}
 41a:	bf00      	nop
 41c:	000007d5 	.word	0x000007d5
 420:	41008000 	.word	0x41008000
 424:	40020000 	.word	0x40020000
 428:	c0000004 	.word	0xc0000004
 42c:	00000399 	.word	0x00000399
 430:	0000035d 	.word	0x0000035d

00000434 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 434:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
 438:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 43a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 43c:	f3bf 8f5f 	dmb	sy
 440:	4770      	bx	lr

00000442 <atomic_leave_critical>:
 442:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
 446:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 448:	f383 8810 	msr	PRIMASK, r3
 44c:	4770      	bx	lr
	...

00000450 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
 450:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
 452:	4b02      	ldr	r3, [pc, #8]	; (45c <delay_init+0xc>)
 454:	6018      	str	r0, [r3, #0]
 456:	4b02      	ldr	r3, [pc, #8]	; (460 <delay_init+0x10>)
 458:	4798      	blx	r3
 45a:	bd08      	pop	{r3, pc}
 45c:	2000001c 	.word	0x2000001c
 460:	000008cd 	.word	0x000008cd

00000464 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
 464:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
 466:	6807      	ldr	r7, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
 468:	b117      	cbz	r7, 470 <timer_add_timer_task+0xc>
 46a:	463c      	mov	r4, r7
 46c:	2600      	movs	r6, #0
 46e:	e00b      	b.n	488 <timer_add_timer_task+0x24>
		list_insert_as_head(list, new_task);
 470:	4b0e      	ldr	r3, [pc, #56]	; (4ac <timer_add_timer_task+0x48>)
 472:	4798      	blx	r3
		return;
 474:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
 476:	68a5      	ldr	r5, [r4, #8]
 478:	442b      	add	r3, r5
 47a:	1a9b      	subs	r3, r3, r2
 47c:	3301      	adds	r3, #1
		}
		if (time_left >= new_task->interval)
 47e:	688d      	ldr	r5, [r1, #8]
 480:	42ab      	cmp	r3, r5
 482:	d209      	bcs.n	498 <timer_add_timer_task+0x34>
			break;
		prev = it;
 484:	4626      	mov	r6, r4
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
 486:	6824      	ldr	r4, [r4, #0]
 488:	b134      	cbz	r4, 498 <timer_add_timer_task+0x34>
		if (it->time_label <= time) {
 48a:	6863      	ldr	r3, [r4, #4]
 48c:	4293      	cmp	r3, r2
 48e:	d8f2      	bhi.n	476 <timer_add_timer_task+0x12>
			time_left = it->interval - (time - it->time_label);
 490:	68a5      	ldr	r5, [r4, #8]
 492:	1a9b      	subs	r3, r3, r2
 494:	442b      	add	r3, r5
 496:	e7f2      	b.n	47e <timer_add_timer_task+0x1a>
	}

	if (it == head) {
 498:	42bc      	cmp	r4, r7
 49a:	d003      	beq.n	4a4 <timer_add_timer_task+0x40>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
 49c:	4630      	mov	r0, r6
 49e:	4b04      	ldr	r3, [pc, #16]	; (4b0 <timer_add_timer_task+0x4c>)
 4a0:	4798      	blx	r3
 4a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
 4a4:	4b01      	ldr	r3, [pc, #4]	; (4ac <timer_add_timer_task+0x48>)
 4a6:	4798      	blx	r3
 4a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 4aa:	bf00      	nop
 4ac:	00000741 	.word	0x00000741
 4b0:	0000076d 	.word	0x0000076d

000004b4 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
 4b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 4b6:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
 4b8:	6906      	ldr	r6, [r0, #16]
 4ba:	3601      	adds	r6, #1
 4bc:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
 4be:	7e03      	ldrb	r3, [r0, #24]
 4c0:	f013 0f01 	tst.w	r3, #1
 4c4:	d105      	bne.n	4d2 <timer_process_counted+0x1e>
 4c6:	7e03      	ldrb	r3, [r0, #24]
 4c8:	f013 0f02 	tst.w	r3, #2
 4cc:	d101      	bne.n	4d2 <timer_process_counted+0x1e>
 4ce:	4605      	mov	r5, r0
 4d0:	e009      	b.n	4e6 <timer_process_counted+0x32>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
 4d2:	7e03      	ldrb	r3, [r0, #24]
 4d4:	f043 0302 	orr.w	r3, r3, #2
 4d8:	7603      	strb	r3, [r0, #24]
		return;
 4da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 4dc:	696f      	ldr	r7, [r5, #20]
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
 4de:	68e3      	ldr	r3, [r4, #12]
 4e0:	4620      	mov	r0, r4
 4e2:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
 4e4:	463c      	mov	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
 4e6:	b19c      	cbz	r4, 510 <timer_process_counted+0x5c>
 4e8:	6863      	ldr	r3, [r4, #4]
 4ea:	1af3      	subs	r3, r6, r3
 4ec:	68a2      	ldr	r2, [r4, #8]
 4ee:	4293      	cmp	r3, r2
 4f0:	d30e      	bcc.n	510 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
 4f2:	f105 0714 	add.w	r7, r5, #20
 4f6:	4638      	mov	r0, r7
 4f8:	4b06      	ldr	r3, [pc, #24]	; (514 <timer_process_counted+0x60>)
 4fa:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
 4fc:	7c23      	ldrb	r3, [r4, #16]
 4fe:	2b01      	cmp	r3, #1
 500:	d1ec      	bne.n	4dc <timer_process_counted+0x28>
			tmp->time_label = time;
 502:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
 504:	4632      	mov	r2, r6
 506:	4621      	mov	r1, r4
 508:	4638      	mov	r0, r7
 50a:	4b03      	ldr	r3, [pc, #12]	; (518 <timer_process_counted+0x64>)
 50c:	4798      	blx	r3
 50e:	e7e5      	b.n	4dc <timer_process_counted+0x28>
 510:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 512:	bf00      	nop
 514:	00000775 	.word	0x00000775
 518:	00000465 	.word	0x00000465

0000051c <timer_init>:
{
 51c:	b538      	push	{r3, r4, r5, lr}
 51e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
 520:	4604      	mov	r4, r0
 522:	b180      	cbz	r0, 546 <timer_init+0x2a>
 524:	b169      	cbz	r1, 542 <timer_init+0x26>
 526:	2001      	movs	r0, #1
 528:	223b      	movs	r2, #59	; 0x3b
 52a:	4908      	ldr	r1, [pc, #32]	; (54c <timer_init+0x30>)
 52c:	4b08      	ldr	r3, [pc, #32]	; (550 <timer_init+0x34>)
 52e:	4798      	blx	r3
	_timer_init(&descr->device, hw);
 530:	4629      	mov	r1, r5
 532:	4620      	mov	r0, r4
 534:	4b07      	ldr	r3, [pc, #28]	; (554 <timer_init+0x38>)
 536:	4798      	blx	r3
	descr->time                           = 0;
 538:	2000      	movs	r0, #0
 53a:	6120      	str	r0, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
 53c:	4b06      	ldr	r3, [pc, #24]	; (558 <timer_init+0x3c>)
 53e:	6023      	str	r3, [r4, #0]
}
 540:	bd38      	pop	{r3, r4, r5, pc}
	ASSERT(descr && hw);
 542:	2000      	movs	r0, #0
 544:	e7f0      	b.n	528 <timer_init+0xc>
 546:	2000      	movs	r0, #0
 548:	e7ee      	b.n	528 <timer_init+0xc>
 54a:	bf00      	nop
 54c:	00000d00 	.word	0x00000d00
 550:	00000725 	.word	0x00000725
 554:	0000097d 	.word	0x0000097d
 558:	000004b5 	.word	0x000004b5

0000055c <timer_start>:
{
 55c:	b510      	push	{r4, lr}
	ASSERT(descr);
 55e:	4604      	mov	r4, r0
 560:	2253      	movs	r2, #83	; 0x53
 562:	4909      	ldr	r1, [pc, #36]	; (588 <timer_start+0x2c>)
 564:	3000      	adds	r0, #0
 566:	bf18      	it	ne
 568:	2001      	movne	r0, #1
 56a:	4b08      	ldr	r3, [pc, #32]	; (58c <timer_start+0x30>)
 56c:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
 56e:	4620      	mov	r0, r4
 570:	4b07      	ldr	r3, [pc, #28]	; (590 <timer_start+0x34>)
 572:	4798      	blx	r3
 574:	b920      	cbnz	r0, 580 <timer_start+0x24>
	_timer_start(&descr->device);
 576:	4620      	mov	r0, r4
 578:	4b06      	ldr	r3, [pc, #24]	; (594 <timer_start+0x38>)
 57a:	4798      	blx	r3
	return ERR_NONE;
 57c:	2000      	movs	r0, #0
 57e:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
 580:	f06f 0010 	mvn.w	r0, #16
}
 584:	bd10      	pop	{r4, pc}
 586:	bf00      	nop
 588:	00000d00 	.word	0x00000d00
 58c:	00000725 	.word	0x00000725
 590:	00000b61 	.word	0x00000b61
 594:	00000b39 	.word	0x00000b39

00000598 <timer_stop>:
{
 598:	b510      	push	{r4, lr}
	ASSERT(descr);
 59a:	4604      	mov	r4, r0
 59c:	2261      	movs	r2, #97	; 0x61
 59e:	4909      	ldr	r1, [pc, #36]	; (5c4 <timer_stop+0x2c>)
 5a0:	3000      	adds	r0, #0
 5a2:	bf18      	it	ne
 5a4:	2001      	movne	r0, #1
 5a6:	4b08      	ldr	r3, [pc, #32]	; (5c8 <timer_stop+0x30>)
 5a8:	4798      	blx	r3
	if (!_timer_is_started(&descr->device)) {
 5aa:	4620      	mov	r0, r4
 5ac:	4b07      	ldr	r3, [pc, #28]	; (5cc <timer_stop+0x34>)
 5ae:	4798      	blx	r3
 5b0:	b120      	cbz	r0, 5bc <timer_stop+0x24>
	_timer_stop(&descr->device);
 5b2:	4620      	mov	r0, r4
 5b4:	4b06      	ldr	r3, [pc, #24]	; (5d0 <timer_stop+0x38>)
 5b6:	4798      	blx	r3
	return ERR_NONE;
 5b8:	2000      	movs	r0, #0
 5ba:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
 5bc:	f06f 0010 	mvn.w	r0, #16
}
 5c0:	bd10      	pop	{r4, pc}
 5c2:	bf00      	nop
 5c4:	00000d00 	.word	0x00000d00
 5c8:	00000725 	.word	0x00000725
 5cc:	00000b61 	.word	0x00000b61
 5d0:	00000b4d 	.word	0x00000b4d

000005d4 <timer_add_task>:
{
 5d4:	b570      	push	{r4, r5, r6, lr}
 5d6:	b082      	sub	sp, #8
 5d8:	460d      	mov	r5, r1
	ASSERT(descr && task);
 5da:	4604      	mov	r4, r0
 5dc:	b320      	cbz	r0, 628 <timer_add_task+0x54>
 5de:	b309      	cbz	r1, 624 <timer_add_task+0x50>
 5e0:	2001      	movs	r0, #1
 5e2:	227a      	movs	r2, #122	; 0x7a
 5e4:	491f      	ldr	r1, [pc, #124]	; (664 <timer_add_task+0x90>)
 5e6:	4b20      	ldr	r3, [pc, #128]	; (668 <timer_add_task+0x94>)
 5e8:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
 5ea:	7e23      	ldrb	r3, [r4, #24]
 5ec:	f043 0301 	orr.w	r3, r3, #1
 5f0:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
 5f2:	f104 0614 	add.w	r6, r4, #20
 5f6:	4629      	mov	r1, r5
 5f8:	4630      	mov	r0, r6
 5fa:	4b1c      	ldr	r3, [pc, #112]	; (66c <timer_add_task+0x98>)
 5fc:	4798      	blx	r3
 5fe:	b9a8      	cbnz	r0, 62c <timer_add_task+0x58>
	task->time_label = descr->time;
 600:	6923      	ldr	r3, [r4, #16]
 602:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
 604:	6922      	ldr	r2, [r4, #16]
 606:	4629      	mov	r1, r5
 608:	4630      	mov	r0, r6
 60a:	4b19      	ldr	r3, [pc, #100]	; (670 <timer_add_task+0x9c>)
 60c:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
 60e:	7e23      	ldrb	r3, [r4, #24]
 610:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 614:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
 616:	7e23      	ldrb	r3, [r4, #24]
 618:	f013 0f02 	tst.w	r3, #2
 61c:	d112      	bne.n	644 <timer_add_task+0x70>
	return ERR_NONE;
 61e:	2000      	movs	r0, #0
}
 620:	b002      	add	sp, #8
 622:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && task);
 624:	2000      	movs	r0, #0
 626:	e7dc      	b.n	5e2 <timer_add_task+0xe>
 628:	2000      	movs	r0, #0
 62a:	e7da      	b.n	5e2 <timer_add_task+0xe>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
 62c:	7e23      	ldrb	r3, [r4, #24]
 62e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 632:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
 634:	227f      	movs	r2, #127	; 0x7f
 636:	490b      	ldr	r1, [pc, #44]	; (664 <timer_add_task+0x90>)
 638:	2000      	movs	r0, #0
 63a:	4b0b      	ldr	r3, [pc, #44]	; (668 <timer_add_task+0x94>)
 63c:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
 63e:	f06f 0011 	mvn.w	r0, #17
 642:	e7ed      	b.n	620 <timer_add_task+0x4c>
		CRITICAL_SECTION_ENTER()
 644:	a801      	add	r0, sp, #4
 646:	4b0b      	ldr	r3, [pc, #44]	; (674 <timer_add_task+0xa0>)
 648:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
 64a:	7e23      	ldrb	r3, [r4, #24]
 64c:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 650:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
 652:	4620      	mov	r0, r4
 654:	4b08      	ldr	r3, [pc, #32]	; (678 <timer_add_task+0xa4>)
 656:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
 658:	a801      	add	r0, sp, #4
 65a:	4b08      	ldr	r3, [pc, #32]	; (67c <timer_add_task+0xa8>)
 65c:	4798      	blx	r3
	return ERR_NONE;
 65e:	2000      	movs	r0, #0
 660:	e7de      	b.n	620 <timer_add_task+0x4c>
 662:	bf00      	nop
 664:	00000d00 	.word	0x00000d00
 668:	00000725 	.word	0x00000725
 66c:	0000072b 	.word	0x0000072b
 670:	00000465 	.word	0x00000465
 674:	00000435 	.word	0x00000435
 678:	00000b79 	.word	0x00000b79
 67c:	00000443 	.word	0x00000443

00000680 <timer_remove_task>:
{
 680:	b570      	push	{r4, r5, r6, lr}
 682:	b082      	sub	sp, #8
 684:	460d      	mov	r5, r1
	ASSERT(descr && task);
 686:	4604      	mov	r4, r0
 688:	b308      	cbz	r0, 6ce <timer_remove_task+0x4e>
 68a:	b1f1      	cbz	r1, 6ca <timer_remove_task+0x4a>
 68c:	2001      	movs	r0, #1
 68e:	2295      	movs	r2, #149	; 0x95
 690:	491d      	ldr	r1, [pc, #116]	; (708 <timer_remove_task+0x88>)
 692:	4b1e      	ldr	r3, [pc, #120]	; (70c <timer_remove_task+0x8c>)
 694:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
 696:	7e23      	ldrb	r3, [r4, #24]
 698:	f043 0301 	orr.w	r3, r3, #1
 69c:	7623      	strb	r3, [r4, #24]
	if (!is_list_element(&descr->tasks, task)) {
 69e:	f104 0614 	add.w	r6, r4, #20
 6a2:	4629      	mov	r1, r5
 6a4:	4630      	mov	r0, r6
 6a6:	4b1a      	ldr	r3, [pc, #104]	; (710 <timer_remove_task+0x90>)
 6a8:	4798      	blx	r3
 6aa:	b190      	cbz	r0, 6d2 <timer_remove_task+0x52>
	list_delete_element(&descr->tasks, task);
 6ac:	4629      	mov	r1, r5
 6ae:	4630      	mov	r0, r6
 6b0:	4b18      	ldr	r3, [pc, #96]	; (714 <timer_remove_task+0x94>)
 6b2:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
 6b4:	7e23      	ldrb	r3, [r4, #24]
 6b6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 6ba:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
 6bc:	7e23      	ldrb	r3, [r4, #24]
 6be:	f013 0f02 	tst.w	r3, #2
 6c2:	d111      	bne.n	6e8 <timer_remove_task+0x68>
	return ERR_NONE;
 6c4:	2000      	movs	r0, #0
}
 6c6:	b002      	add	sp, #8
 6c8:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && task);
 6ca:	2000      	movs	r0, #0
 6cc:	e7df      	b.n	68e <timer_remove_task+0xe>
 6ce:	2000      	movs	r0, #0
 6d0:	e7dd      	b.n	68e <timer_remove_task+0xe>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
 6d2:	7e23      	ldrb	r3, [r4, #24]
 6d4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 6d8:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
 6da:	229a      	movs	r2, #154	; 0x9a
 6dc:	490a      	ldr	r1, [pc, #40]	; (708 <timer_remove_task+0x88>)
 6de:	4b0b      	ldr	r3, [pc, #44]	; (70c <timer_remove_task+0x8c>)
 6e0:	4798      	blx	r3
		return ERR_NOT_FOUND;
 6e2:	f06f 0009 	mvn.w	r0, #9
 6e6:	e7ee      	b.n	6c6 <timer_remove_task+0x46>
		CRITICAL_SECTION_ENTER()
 6e8:	a801      	add	r0, sp, #4
 6ea:	4b0b      	ldr	r3, [pc, #44]	; (718 <timer_remove_task+0x98>)
 6ec:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
 6ee:	7e23      	ldrb	r3, [r4, #24]
 6f0:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
 6f4:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
 6f6:	4620      	mov	r0, r4
 6f8:	4b08      	ldr	r3, [pc, #32]	; (71c <timer_remove_task+0x9c>)
 6fa:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
 6fc:	a801      	add	r0, sp, #4
 6fe:	4b08      	ldr	r3, [pc, #32]	; (720 <timer_remove_task+0xa0>)
 700:	4798      	blx	r3
	return ERR_NONE;
 702:	2000      	movs	r0, #0
 704:	e7df      	b.n	6c6 <timer_remove_task+0x46>
 706:	bf00      	nop
 708:	00000d00 	.word	0x00000d00
 70c:	00000725 	.word	0x00000725
 710:	0000072b 	.word	0x0000072b
 714:	00000785 	.word	0x00000785
 718:	00000435 	.word	0x00000435
 71c:	00000b79 	.word	0x00000b79
 720:	00000443 	.word	0x00000443

00000724 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
 724:	b900      	cbnz	r0, 728 <assert+0x4>
		__asm("BKPT #0");
 726:	be00      	bkpt	0x0000
 728:	4770      	bx	lr

0000072a <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
 72a:	6803      	ldr	r3, [r0, #0]
 72c:	b11b      	cbz	r3, 736 <is_list_element+0xc>
		if (it == element) {
 72e:	428b      	cmp	r3, r1
 730:	d003      	beq.n	73a <is_list_element+0x10>
	for (it = list->head; it; it = it->next) {
 732:	681b      	ldr	r3, [r3, #0]
 734:	e7fa      	b.n	72c <is_list_element+0x2>
			return true;
		}
	}

	return false;
 736:	2000      	movs	r0, #0
 738:	4770      	bx	lr
			return true;
 73a:	2001      	movs	r0, #1
}
 73c:	4770      	bx	lr
	...

00000740 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
 740:	b538      	push	{r3, r4, r5, lr}
 742:	4604      	mov	r4, r0
 744:	460d      	mov	r5, r1
	ASSERT(!is_list_element(list, element));
 746:	4b06      	ldr	r3, [pc, #24]	; (760 <list_insert_as_head+0x20>)
 748:	4798      	blx	r3
 74a:	f080 0001 	eor.w	r0, r0, #1
 74e:	2239      	movs	r2, #57	; 0x39
 750:	4904      	ldr	r1, [pc, #16]	; (764 <list_insert_as_head+0x24>)
 752:	b2c0      	uxtb	r0, r0
 754:	4b04      	ldr	r3, [pc, #16]	; (768 <list_insert_as_head+0x28>)
 756:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
 758:	6823      	ldr	r3, [r4, #0]
 75a:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
 75c:	6025      	str	r5, [r4, #0]
 75e:	bd38      	pop	{r3, r4, r5, pc}
 760:	0000072b 	.word	0x0000072b
 764:	00000d18 	.word	0x00000d18
 768:	00000725 	.word	0x00000725

0000076c <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
 76c:	6803      	ldr	r3, [r0, #0]
 76e:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
 770:	6001      	str	r1, [r0, #0]
 772:	4770      	bx	lr

00000774 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
 774:	6803      	ldr	r3, [r0, #0]
 776:	b11b      	cbz	r3, 780 <list_remove_head+0xc>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
 778:	681a      	ldr	r2, [r3, #0]
 77a:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
 77c:	4618      	mov	r0, r3
 77e:	4770      	bx	lr
	}

	return NULL;
 780:	2000      	movs	r0, #0
}
 782:	4770      	bx	lr

00000784 <list_delete_element>:
/**
 * \brief Removes list element
 */
bool list_delete_element(struct list_descriptor *const list, const void *const element)
{
	if (!element) {
 784:	b1a1      	cbz	r1, 7b0 <list_delete_element+0x2c>
{
 786:	b410      	push	{r4}
 788:	460c      	mov	r4, r1
		return false;
	}

	if (list->head == element) {
 78a:	6803      	ldr	r3, [r0, #0]
 78c:	4299      	cmp	r1, r3
 78e:	d104      	bne.n	79a <list_delete_element+0x16>
		list->head = list->head->next;
 790:	681b      	ldr	r3, [r3, #0]
 792:	6003      	str	r3, [r0, #0]
		return true;
 794:	2001      	movs	r0, #1
 796:	e008      	b.n	7aa <list_delete_element+0x26>
	} else {
		struct list_element *it = list->head;

		while (it && it->next != element) {
			it = it->next;
 798:	4613      	mov	r3, r2
		while (it && it->next != element) {
 79a:	b113      	cbz	r3, 7a2 <list_delete_element+0x1e>
 79c:	681a      	ldr	r2, [r3, #0]
 79e:	4294      	cmp	r4, r2
 7a0:	d1fa      	bne.n	798 <list_delete_element+0x14>
		}
		if (it) {
 7a2:	b13b      	cbz	r3, 7b4 <list_delete_element+0x30>
			it->next = ((struct list_element *)element)->next;
 7a4:	6822      	ldr	r2, [r4, #0]
 7a6:	601a      	str	r2, [r3, #0]
			return true;
 7a8:	2001      	movs	r0, #1
		}
	}

	return false;
}
 7aa:	f85d 4b04 	ldr.w	r4, [sp], #4
 7ae:	4770      	bx	lr
		return false;
 7b0:	2000      	movs	r0, #0
 7b2:	4770      	bx	lr
	return false;
 7b4:	2000      	movs	r0, #0
 7b6:	e7f8      	b.n	7aa <list_delete_element+0x26>

000007b8 <_irq_set>:
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 7b8:	0943      	lsrs	r3, r0, #5
 7ba:	f000 001f 	and.w	r0, r0, #31
 7be:	2201      	movs	r2, #1
 7c0:	fa02 f000 	lsl.w	r0, r2, r0
 7c4:	3340      	adds	r3, #64	; 0x40
 7c6:	4a02      	ldr	r2, [pc, #8]	; (7d0 <_irq_set+0x18>)
 7c8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 7cc:	4770      	bx	lr
 7ce:	bf00      	nop
 7d0:	e000e100 	.word	0xe000e100

000007d4 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
 7d4:	b508      	push	{r3, lr}
}

static inline void hri_nvmctrl_set_CTRLA_RWS_bf(const void *const hw, hri_nvmctrl_ctrla_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
 7d6:	4a08      	ldr	r2, [pc, #32]	; (7f8 <_init_chip+0x24>)
 7d8:	8813      	ldrh	r3, [r2, #0]
 7da:	b29b      	uxth	r3, r3
 7dc:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
 7de:	4b07      	ldr	r3, [pc, #28]	; (7fc <_init_chip+0x28>)
 7e0:	4798      	blx	r3
	_oscctrl_init_sources();
 7e2:	4b07      	ldr	r3, [pc, #28]	; (800 <_init_chip+0x2c>)
 7e4:	4798      	blx	r3
	_mclk_init();
 7e6:	4b07      	ldr	r3, [pc, #28]	; (804 <_init_chip+0x30>)
 7e8:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
 7ea:	4b07      	ldr	r3, [pc, #28]	; (808 <_init_chip+0x34>)
 7ec:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
 7ee:	f640 70ff 	movw	r0, #4095	; 0xfff
 7f2:	4b06      	ldr	r3, [pc, #24]	; (80c <_init_chip+0x38>)
 7f4:	4798      	blx	r3
 7f6:	bd08      	pop	{r3, pc}
 7f8:	41004000 	.word	0x41004000
 7fc:	00000841 	.word	0x00000841
 800:	00000855 	.word	0x00000855
 804:	00000835 	.word	0x00000835
 808:	00000871 	.word	0x00000871
 80c:	00000811 	.word	0x00000811

00000810 <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
 810:	f010 0f01 	tst.w	r0, #1
 814:	d008      	beq.n	828 <_gclk_init_generators_by_fref+0x18>
	((Gclk *)hw)->GENCTRL[index].reg = data;
 816:	4a05      	ldr	r2, [pc, #20]	; (82c <_gclk_init_generators_by_fref+0x1c>)
 818:	4b05      	ldr	r3, [pc, #20]	; (830 <_gclk_init_generators_by_fref+0x20>)
 81a:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
 81c:	4b04      	ldr	r3, [pc, #16]	; (830 <_gclk_init_generators_by_fref+0x20>)
 81e:	685a      	ldr	r2, [r3, #4]
 820:	f643 73fd 	movw	r3, #16381	; 0x3ffd
 824:	421a      	tst	r2, r3
 826:	d1f9      	bne.n	81c <_gclk_init_generators_by_fref+0xc>
 828:	4770      	bx	lr
 82a:	bf00      	nop
 82c:	00010101 	.word	0x00010101
 830:	40001c00 	.word	0x40001c00

00000834 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
 834:	2201      	movs	r2, #1
 836:	4b01      	ldr	r3, [pc, #4]	; (83c <_mclk_init+0x8>)
 838:	715a      	strb	r2, [r3, #5]
 83a:	4770      	bx	lr
 83c:	40000800 	.word	0x40000800

00000840 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
 840:	4b03      	ldr	r3, [pc, #12]	; (850 <_osc32kctrl_init_sources+0x10>)
 842:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
 844:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
 848:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
 84a:	2201      	movs	r2, #1
 84c:	741a      	strb	r2, [r3, #16]
 84e:	4770      	bx	lr
 850:	40001400 	.word	0x40001400

00000854 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_XOSCCTRL_reg(const void *const hw, uint8_t index, hri_oscctrl_xoscctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->XOSCCTRL[index].reg = data;
 854:	4a04      	ldr	r2, [pc, #16]	; (868 <_oscctrl_init_sources+0x14>)
 856:	4b05      	ldr	r3, [pc, #20]	; (86c <_oscctrl_init_sources+0x18>)
 858:	619a      	str	r2, [r3, #24]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_XOSCRDY1) >> OSCCTRL_STATUS_XOSCRDY1_Pos;
 85a:	4b04      	ldr	r3, [pc, #16]	; (86c <_oscctrl_init_sources+0x18>)
 85c:	691b      	ldr	r3, [r3, #16]
	        | (CONF_XOSC1_XTALEN << OSCCTRL_XOSCCTRL_XTALEN_Pos) | (CONF_XOSC1_ENABLE << OSCCTRL_XOSCCTRL_ENABLE_Pos));
#endif

#if CONF_XOSC1_CONFIG == 1
#if CONF_XOSC1_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_XOSCRDY1_bit(hw))
 85e:	f013 0f02 	tst.w	r3, #2
 862:	d0fa      	beq.n	85a <_oscctrl_init_sources+0x6>
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
 864:	4770      	bx	lr
 866:	bf00      	nop
 868:	03002606 	.word	0x03002606
 86c:	40001000 	.word	0x40001000

00000870 <_oscctrl_init_referenced_generators>:

void _oscctrl_init_referenced_generators(void)
{
 870:	4770      	bx	lr
	...

00000874 <RAMECC_Handler>:

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
 874:	b500      	push	{lr}
 876:	b083      	sub	sp, #12
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
 878:	4b0d      	ldr	r3, [pc, #52]	; (8b0 <RAMECC_Handler+0x3c>)
 87a:	789b      	ldrb	r3, [r3, #2]
 87c:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
 87e:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
 880:	9b01      	ldr	r3, [sp, #4]
 882:	f013 0f02 	tst.w	r3, #2
 886:	d006      	beq.n	896 <RAMECC_Handler+0x22>
 888:	4b0a      	ldr	r3, [pc, #40]	; (8b4 <RAMECC_Handler+0x40>)
 88a:	681b      	ldr	r3, [r3, #0]
 88c:	b11b      	cbz	r3, 896 <RAMECC_Handler+0x22>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
 88e:	4a08      	ldr	r2, [pc, #32]	; (8b0 <RAMECC_Handler+0x3c>)
 890:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.dual_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
 892:	4798      	blx	r3
 894:	e009      	b.n	8aa <RAMECC_Handler+0x36>
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
 896:	9b01      	ldr	r3, [sp, #4]
 898:	f013 0f01 	tst.w	r3, #1
 89c:	d005      	beq.n	8aa <RAMECC_Handler+0x36>
 89e:	4b05      	ldr	r3, [pc, #20]	; (8b4 <RAMECC_Handler+0x40>)
 8a0:	685b      	ldr	r3, [r3, #4]
 8a2:	b113      	cbz	r3, 8aa <RAMECC_Handler+0x36>
 8a4:	4a02      	ldr	r2, [pc, #8]	; (8b0 <RAMECC_Handler+0x3c>)
 8a6:	6850      	ldr	r0, [r2, #4]
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
 8a8:	4798      	blx	r3
	} else {
		return;
	}
}
 8aa:	b003      	add	sp, #12
 8ac:	f85d fb04 	ldr.w	pc, [sp], #4
 8b0:	41020000 	.word	0x41020000
 8b4:	20000058 	.word	0x20000058

000008b8 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
 8b8:	4b03      	ldr	r3, [pc, #12]	; (8c8 <_system_time_init+0x10>)
 8ba:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
 8be:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
 8c0:	2205      	movs	r2, #5
 8c2:	601a      	str	r2, [r3, #0]
 8c4:	4770      	bx	lr
 8c6:	bf00      	nop
 8c8:	e000e010 	.word	0xe000e010

000008cc <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
 8cc:	b508      	push	{r3, lr}
	_system_time_init(hw);
 8ce:	4b01      	ldr	r3, [pc, #4]	; (8d4 <_delay_init+0x8>)
 8d0:	4798      	blx	r3
 8d2:	bd08      	pop	{r3, pc}
 8d4:	000008b9 	.word	0x000008b9

000008d8 <tc_interrupt_handler>:
 * \internal TC interrupt handler for Timer
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
 8d8:	b508      	push	{r3, lr}
	void *const hw = device->hw;
 8da:	68c3      	ldr	r3, [r0, #12]
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
 8dc:	7a9a      	ldrb	r2, [r3, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
 8de:	f012 0f01 	tst.w	r2, #1
 8e2:	d100      	bne.n	8e6 <tc_interrupt_handler+0xe>
 8e4:	bd08      	pop	{r3, pc}
}

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
 8e6:	2201      	movs	r2, #1
 8e8:	729a      	strb	r2, [r3, #10]
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
 8ea:	6803      	ldr	r3, [r0, #0]
 8ec:	4798      	blx	r3
	}
}
 8ee:	e7f9      	b.n	8e4 <tc_interrupt_handler+0xc>

000008f0 <_tc_init_irq_param>:
/**
 * \brief Init irq param with the given tc hardware instance
 */
static void _tc_init_irq_param(const void *const hw, void *dev)
{
	if (hw == TC1) {
 8f0:	4b03      	ldr	r3, [pc, #12]	; (900 <_tc_init_irq_param+0x10>)
 8f2:	4298      	cmp	r0, r3
 8f4:	d000      	beq.n	8f8 <_tc_init_irq_param+0x8>
 8f6:	4770      	bx	lr
		_tc1_dev = (struct _timer_device *)dev;
 8f8:	4b02      	ldr	r3, [pc, #8]	; (904 <_tc_init_irq_param+0x14>)
 8fa:	6019      	str	r1, [r3, #0]
	}
}
 8fc:	e7fb      	b.n	8f6 <_tc_init_irq_param+0x6>
 8fe:	bf00      	nop
 900:	40003c00 	.word	0x40003c00
 904:	20000020 	.word	0x20000020

00000908 <get_tc_index>:
{
 908:	b570      	push	{r4, r5, r6, lr}
 90a:	b088      	sub	sp, #32
 90c:	4606      	mov	r6, r0
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
 90e:	466c      	mov	r4, sp
 910:	4d17      	ldr	r5, [pc, #92]	; (970 <get_tc_index+0x68>)
 912:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 914:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 916:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 91a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
 91e:	2300      	movs	r3, #0
 920:	2b07      	cmp	r3, #7
 922:	d80a      	bhi.n	93a <get_tc_index+0x32>
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
 924:	aa08      	add	r2, sp, #32
 926:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 92a:	f852 2c20 	ldr.w	r2, [r2, #-32]
 92e:	42b2      	cmp	r2, r6
 930:	d001      	beq.n	936 <get_tc_index+0x2e>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
 932:	3301      	adds	r3, #1
 934:	e7f4      	b.n	920 <get_tc_index+0x18>
			return i;
 936:	b2db      	uxtb	r3, r3
 938:	e000      	b.n	93c <get_tc_index+0x34>
		}
	}
	return 0;
 93a:	2300      	movs	r3, #0
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
 93c:	2200      	movs	r2, #0
 93e:	b14a      	cbz	r2, 954 <get_tc_index+0x4c>
	ASSERT(false);
 940:	f44f 729e 	mov.w	r2, #316	; 0x13c
 944:	490b      	ldr	r1, [pc, #44]	; (974 <get_tc_index+0x6c>)
 946:	2000      	movs	r0, #0
 948:	4b0b      	ldr	r3, [pc, #44]	; (978 <get_tc_index+0x70>)
 94a:	4798      	blx	r3
	return -1;
 94c:	f04f 30ff 	mov.w	r0, #4294967295
}
 950:	b008      	add	sp, #32
 952:	bd70      	pop	{r4, r5, r6, pc}
		if (_tcs[i].number == index) {
 954:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 958:	0088      	lsls	r0, r1, #2
 95a:	4905      	ldr	r1, [pc, #20]	; (970 <get_tc_index+0x68>)
 95c:	4401      	add	r1, r0
 95e:	f891 1020 	ldrb.w	r1, [r1, #32]
 962:	4299      	cmp	r1, r3
 964:	d002      	beq.n	96c <get_tc_index+0x64>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
 966:	3201      	adds	r2, #1
 968:	b2d2      	uxtb	r2, r2
 96a:	e7e8      	b.n	93e <get_tc_index+0x36>
			return i;
 96c:	b250      	sxtb	r0, r2
 96e:	e7ef      	b.n	950 <get_tc_index+0x48>
 970:	00000d38 	.word	0x00000d38
 974:	00000d6c 	.word	0x00000d6c
 978:	00000725 	.word	0x00000725

0000097c <_timer_init>:
{
 97c:	b570      	push	{r4, r5, r6, lr}
 97e:	4606      	mov	r6, r0
 980:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
 982:	4608      	mov	r0, r1
 984:	4b66      	ldr	r3, [pc, #408]	; (b20 <_timer_init+0x1a4>)
 986:	4798      	blx	r3
 988:	4605      	mov	r5, r0
	device->hw = hw;
 98a:	60f4      	str	r4, [r6, #12]
	ASSERT(ARRAY_SIZE(_tcs));
 98c:	228d      	movs	r2, #141	; 0x8d
 98e:	4965      	ldr	r1, [pc, #404]	; (b24 <_timer_init+0x1a8>)
 990:	2001      	movs	r0, #1
 992:	4b65      	ldr	r3, [pc, #404]	; (b28 <_timer_init+0x1ac>)
 994:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
 996:	6923      	ldr	r3, [r4, #16]
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
 998:	f013 0f01 	tst.w	r3, #1
 99c:	d119      	bne.n	9d2 <_timer_init+0x56>
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 99e:	6923      	ldr	r3, [r4, #16]
 9a0:	f013 0f03 	tst.w	r3, #3
 9a4:	d1fb      	bne.n	99e <_timer_init+0x22>

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
 9a6:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
 9a8:	f013 0f02 	tst.w	r3, #2
 9ac:	d00b      	beq.n	9c6 <_timer_init+0x4a>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
 9ae:	6823      	ldr	r3, [r4, #0]
 9b0:	f023 0302 	bic.w	r3, r3, #2
 9b4:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 9b6:	6923      	ldr	r3, [r4, #16]
 9b8:	f013 0f03 	tst.w	r3, #3
 9bc:	d1fb      	bne.n	9b6 <_timer_init+0x3a>
 9be:	6923      	ldr	r3, [r4, #16]
 9c0:	f013 0f02 	tst.w	r3, #2
 9c4:	d1fb      	bne.n	9be <_timer_init+0x42>
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
 9c6:	2301      	movs	r3, #1
 9c8:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 9ca:	6923      	ldr	r3, [r4, #16]
 9cc:	f013 0f03 	tst.w	r3, #3
 9d0:	d1fb      	bne.n	9ca <_timer_init+0x4e>
 9d2:	6923      	ldr	r3, [r4, #16]
 9d4:	f013 0f01 	tst.w	r3, #1
 9d8:	d1fb      	bne.n	9d2 <_timer_init+0x56>
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
 9da:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 9de:	009a      	lsls	r2, r3, #2
 9e0:	4b52      	ldr	r3, [pc, #328]	; (b2c <_timer_init+0x1b0>)
 9e2:	4413      	add	r3, r2
 9e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
 9e6:	6023      	str	r3, [r4, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 9e8:	6923      	ldr	r3, [r4, #16]
 9ea:	f013 0f03 	tst.w	r3, #3
 9ee:	d1fb      	bne.n	9e8 <_timer_init+0x6c>
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
 9f0:	00aa      	lsls	r2, r5, #2
 9f2:	442a      	add	r2, r5
 9f4:	0091      	lsls	r1, r2, #2
 9f6:	4b4d      	ldr	r3, [pc, #308]	; (b2c <_timer_init+0x1b0>)
 9f8:	440b      	add	r3, r1
 9fa:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
}

static inline void hri_tc_write_DBGCTRL_reg(const void *const hw, hri_tc_dbgctrl_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
 9fe:	73e2      	strb	r2, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
 a00:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
 a02:	80e2      	strh	r2, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
 a04:	2201      	movs	r2, #1
 a06:	7322      	strb	r2, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
 a08:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 a0a:	f003 030c 	and.w	r3, r3, #12
 a0e:	2b08      	cmp	r3, #8
 a10:	d056      	beq.n	ac0 <_timer_init+0x144>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
 a12:	2b00      	cmp	r3, #0
 a14:	d163      	bne.n	ade <_timer_init+0x162>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
 a16:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 a1a:	009a      	lsls	r2, r3, #2
 a1c:	4b43      	ldr	r3, [pc, #268]	; (b2c <_timer_init+0x1b0>)
 a1e:	4413      	add	r3, r2
 a20:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount16_write_CC_reg(const void *const hw, uint8_t index, hri_tccount16_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CC[index].reg = data;
 a22:	83a3      	strh	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 a24:	6923      	ldr	r3, [r4, #16]
 a26:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 a2a:	d1fb      	bne.n	a24 <_timer_init+0xa8>
	((Tc *)hw)->COUNT16.CC[index].reg = data;
 a2c:	2300      	movs	r3, #0
 a2e:	83e3      	strh	r3, [r4, #30]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 a30:	6923      	ldr	r3, [r4, #16]
 a32:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 a36:	d1fb      	bne.n	a30 <_timer_init+0xb4>
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
 a38:	2301      	movs	r3, #1
 a3a:	7263      	strb	r3, [r4, #9]
	_tc_init_irq_param(hw, (void *)device);
 a3c:	4631      	mov	r1, r6
 a3e:	4620      	mov	r0, r4
 a40:	4b3b      	ldr	r3, [pc, #236]	; (b30 <_timer_init+0x1b4>)
 a42:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
 a44:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 a48:	009a      	lsls	r2, r3, #2
 a4a:	4b38      	ldr	r3, [pc, #224]	; (b2c <_timer_init+0x1b0>)
 a4c:	4413      	add	r3, r2
 a4e:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
 a52:	2b00      	cmp	r3, #0
 a54:	db0d      	blt.n	a72 <_timer_init+0xf6>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 a56:	095a      	lsrs	r2, r3, #5
 a58:	f003 031f 	and.w	r3, r3, #31
 a5c:	2101      	movs	r1, #1
 a5e:	fa01 f303 	lsl.w	r3, r1, r3
 a62:	3220      	adds	r2, #32
 a64:	4933      	ldr	r1, [pc, #204]	; (b34 <_timer_init+0x1b8>)
 a66:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 a6a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 a6e:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
 a72:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 a76:	009a      	lsls	r2, r3, #2
 a78:	4b2c      	ldr	r3, [pc, #176]	; (b2c <_timer_init+0x1b0>)
 a7a:	4413      	add	r3, r2
 a7c:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
 a80:	2b00      	cmp	r3, #0
 a82:	db09      	blt.n	a98 <_timer_init+0x11c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 a84:	095a      	lsrs	r2, r3, #5
 a86:	f003 031f 	and.w	r3, r3, #31
 a8a:	2101      	movs	r1, #1
 a8c:	fa01 f303 	lsl.w	r3, r1, r3
 a90:	3260      	adds	r2, #96	; 0x60
 a92:	4928      	ldr	r1, [pc, #160]	; (b34 <_timer_init+0x1b8>)
 a94:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	NVIC_EnableIRQ(_tcs[i].irq);
 a98:	eb05 0585 	add.w	r5, r5, r5, lsl #2
 a9c:	00aa      	lsls	r2, r5, #2
 a9e:	4b23      	ldr	r3, [pc, #140]	; (b2c <_timer_init+0x1b0>)
 aa0:	4413      	add	r3, r2
 aa2:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
 aa6:	2b00      	cmp	r3, #0
 aa8:	db08      	blt.n	abc <_timer_init+0x140>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 aaa:	0959      	lsrs	r1, r3, #5
 aac:	f003 031f 	and.w	r3, r3, #31
 ab0:	2201      	movs	r2, #1
 ab2:	fa02 f303 	lsl.w	r3, r2, r3
 ab6:	4a1f      	ldr	r2, [pc, #124]	; (b34 <_timer_init+0x1b8>)
 ab8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
 abc:	2000      	movs	r0, #0
 abe:	bd70      	pop	{r4, r5, r6, pc}
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
 ac0:	4b1a      	ldr	r3, [pc, #104]	; (b2c <_timer_init+0x1b0>)
 ac2:	440b      	add	r3, r1
 ac4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}

static inline void hri_tccount32_write_CC_reg(const void *const hw, uint8_t index, hri_tccount32_cc_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT32.CC[index].reg = data;
 ac6:	61e3      	str	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 ac8:	6923      	ldr	r3, [r4, #16]
 aca:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 ace:	d1fb      	bne.n	ac8 <_timer_init+0x14c>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
 ad0:	2300      	movs	r3, #0
 ad2:	6223      	str	r3, [r4, #32]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 ad4:	6923      	ldr	r3, [r4, #16]
 ad6:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 ada:	d1fb      	bne.n	ad4 <_timer_init+0x158>
 adc:	e7ac      	b.n	a38 <_timer_init+0xbc>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
 ade:	2b04      	cmp	r3, #4
 ae0:	d1aa      	bne.n	a38 <_timer_init+0xbc>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
 ae2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 ae6:	009a      	lsls	r2, r3, #2
 ae8:	4b10      	ldr	r3, [pc, #64]	; (b2c <_timer_init+0x1b0>)
 aea:	4413      	add	r3, r2
 aec:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
 af0:	7723      	strb	r3, [r4, #28]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 af2:	6923      	ldr	r3, [r4, #16]
 af4:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 af8:	d1fb      	bne.n	af2 <_timer_init+0x176>
	((Tc *)hw)->COUNT8.CC[index].reg = data;
 afa:	2300      	movs	r3, #0
 afc:	7763      	strb	r3, [r4, #29]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 afe:	6923      	ldr	r3, [r4, #16]
 b00:	f013 0fc0 	tst.w	r3, #192	; 0xc0
 b04:	d1fb      	bne.n	afe <_timer_init+0x182>
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
 b06:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 b0a:	009a      	lsls	r2, r3, #2
 b0c:	4b07      	ldr	r3, [pc, #28]	; (b2c <_timer_init+0x1b0>)
 b0e:	4413      	add	r3, r2
 b10:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
 b14:	76e3      	strb	r3, [r4, #27]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 b16:	6923      	ldr	r3, [r4, #16]
 b18:	f013 0f20 	tst.w	r3, #32
 b1c:	d1fb      	bne.n	b16 <_timer_init+0x19a>
 b1e:	e78b      	b.n	a38 <_timer_init+0xbc>
 b20:	00000909 	.word	0x00000909
 b24:	00000d6c 	.word	0x00000d6c
 b28:	00000725 	.word	0x00000725
 b2c:	00000d38 	.word	0x00000d38
 b30:	000008f1 	.word	0x000008f1
 b34:	e000e100 	.word	0xe000e100

00000b38 <_timer_start>:
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
 b38:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
 b3a:	6813      	ldr	r3, [r2, #0]
 b3c:	f043 0302 	orr.w	r3, r3, #2
 b40:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 b42:	6913      	ldr	r3, [r2, #16]
 b44:	f013 0f03 	tst.w	r3, #3
 b48:	d1fb      	bne.n	b42 <_timer_start+0xa>
}
 b4a:	4770      	bx	lr

00000b4c <_timer_stop>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
 b4c:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
 b4e:	6813      	ldr	r3, [r2, #0]
 b50:	f023 0302 	bic.w	r3, r3, #2
 b54:	6013      	str	r3, [r2, #0]
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
 b56:	6913      	ldr	r3, [r2, #16]
 b58:	f013 0f03 	tst.w	r3, #3
 b5c:	d1fb      	bne.n	b56 <_timer_stop+0xa>
}
 b5e:	4770      	bx	lr

00000b60 <_timer_is_started>:
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
 b60:	68c2      	ldr	r2, [r0, #12]
 b62:	6913      	ldr	r3, [r2, #16]
 b64:	f013 0f03 	tst.w	r3, #3
 b68:	d1fb      	bne.n	b62 <_timer_is_started+0x2>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
 b6a:	6810      	ldr	r0, [r2, #0]
	tmp = (tmp & TC_CTRLA_ENABLE) >> TC_CTRLA_ENABLE_Pos;
 b6c:	f3c0 0040 	ubfx	r0, r0, #1, #1
}
 b70:	4770      	bx	lr

00000b72 <_tc_get_timer>:
}
 b72:	2000      	movs	r0, #0
 b74:	4770      	bx	lr
	...

00000b78 <_timer_set_irq>:
{
 b78:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
 b7a:	68c0      	ldr	r0, [r0, #12]
 b7c:	4b09      	ldr	r3, [pc, #36]	; (ba4 <_timer_set_irq+0x2c>)
 b7e:	4798      	blx	r3
 b80:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
 b82:	f240 120f 	movw	r2, #271	; 0x10f
 b86:	4908      	ldr	r1, [pc, #32]	; (ba8 <_timer_set_irq+0x30>)
 b88:	2001      	movs	r0, #1
 b8a:	4b08      	ldr	r3, [pc, #32]	; (bac <_timer_set_irq+0x34>)
 b8c:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
 b8e:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 b92:	00a2      	lsls	r2, r4, #2
 b94:	4b06      	ldr	r3, [pc, #24]	; (bb0 <_timer_set_irq+0x38>)
 b96:	4413      	add	r3, r2
 b98:	f893 0022 	ldrb.w	r0, [r3, #34]	; 0x22
 b9c:	4b05      	ldr	r3, [pc, #20]	; (bb4 <_timer_set_irq+0x3c>)
 b9e:	4798      	blx	r3
 ba0:	bd10      	pop	{r4, pc}
 ba2:	bf00      	nop
 ba4:	00000909 	.word	0x00000909
 ba8:	00000d6c 	.word	0x00000d6c
 bac:	00000725 	.word	0x00000725
 bb0:	00000d38 	.word	0x00000d38
 bb4:	000007b9 	.word	0x000007b9

00000bb8 <TC1_Handler>:
{
 bb8:	b508      	push	{r3, lr}
	tc_interrupt_handler(_tc1_dev);
 bba:	4b02      	ldr	r3, [pc, #8]	; (bc4 <TC1_Handler+0xc>)
 bbc:	6818      	ldr	r0, [r3, #0]
 bbe:	4b02      	ldr	r3, [pc, #8]	; (bc8 <TC1_Handler+0x10>)
 bc0:	4798      	blx	r3
 bc2:	bd08      	pop	{r3, pc}
 bc4:	20000020 	.word	0x20000020
 bc8:	000008d9 	.word	0x000008d9

00000bcc <TIMER_0_task1_cb>:
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = mask;
 bcc:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 bd0:	4b01      	ldr	r3, [pc, #4]	; (bd8 <TIMER_0_task1_cb+0xc>)
 bd2:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
 bd6:	4770      	bx	lr
 bd8:	41008000 	.word	0x41008000

00000bdc <configure_timer>:
	}
}


// Initialisierung und Konfiguration des Timers
void configure_timer( uint16_t interval ) {
 bdc:	b510      	push	{r4, lr}

	TIMER_0_task1.interval = interval;
 bde:	4907      	ldr	r1, [pc, #28]	; (bfc <configure_timer+0x20>)
 be0:	6088      	str	r0, [r1, #8]
	TIMER_0_task1.cb = TIMER_0_task1_cb;
 be2:	4b07      	ldr	r3, [pc, #28]	; (c00 <configure_timer+0x24>)
 be4:	60cb      	str	r3, [r1, #12]
	TIMER_0_task1.mode = TIMER_TASK_REPEAT;
 be6:	2301      	movs	r3, #1
 be8:	740b      	strb	r3, [r1, #16]

	// Timer starten
	timer_add_task(&TIMER_0, &TIMER_0_task1);  // Nutze TIMER_0
 bea:	4c06      	ldr	r4, [pc, #24]	; (c04 <configure_timer+0x28>)
 bec:	4620      	mov	r0, r4
 bee:	4b06      	ldr	r3, [pc, #24]	; (c08 <configure_timer+0x2c>)
 bf0:	4798      	blx	r3
	//timer_stop(&TIMER_0);  // Standardmig Timer stoppen
	timer_start(&TIMER_0);
 bf2:	4620      	mov	r0, r4
 bf4:	4b05      	ldr	r3, [pc, #20]	; (c0c <configure_timer+0x30>)
 bf6:	4798      	blx	r3
 bf8:	bd10      	pop	{r4, pc}
 bfa:	bf00      	nop
 bfc:	20000024 	.word	0x20000024
 c00:	00000bcd 	.word	0x00000bcd
 c04:	2000003c 	.word	0x2000003c
 c08:	000005d5 	.word	0x000005d5
 c0c:	0000055d 	.word	0x0000055d

00000c10 <main>:
{
 c10:	b500      	push	{lr}
 c12:	b083      	sub	sp, #12
	atmel_start_init();
 c14:	4b1f      	ldr	r3, [pc, #124]	; (c94 <main+0x84>)
 c16:	4798      	blx	r3
	configure_timer(TIMER_INTERVAL_SLOW);
 c18:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 c1c:	4b1e      	ldr	r3, [pc, #120]	; (c98 <main+0x88>)
 c1e:	4798      	blx	r3
 c20:	e002      	b.n	c28 <main+0x18>
			if(button_pressed){
 c22:	4b1e      	ldr	r3, [pc, #120]	; (c9c <main+0x8c>)
 c24:	7d1b      	ldrb	r3, [r3, #20]
 c26:	bb23      	cbnz	r3, c72 <main+0x62>
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
 c28:	a801      	add	r0, sp, #4
 c2a:	4b1d      	ldr	r3, [pc, #116]	; (ca0 <main+0x90>)
 c2c:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
 c2e:	4b1d      	ldr	r3, [pc, #116]	; (ca4 <main+0x94>)
 c30:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
	return ((Port *)hw)->Group[submodule_index].IN.reg;
 c34:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
 c38:	f8d3 4090 	ldr.w	r4, [r3, #144]	; 0x90

	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
 c3c:	4054      	eors	r4, r2
 c3e:	400c      	ands	r4, r1
 c40:	4054      	eors	r4, r2

	CRITICAL_SECTION_LEAVE();
 c42:	a801      	add	r0, sp, #4
 c44:	4b18      	ldr	r3, [pc, #96]	; (ca8 <main+0x98>)
 c46:	4798      	blx	r3
		if(gpio_get_pin_level(SW0) == false){
 c48:	2c00      	cmp	r4, #0
 c4a:	dbea      	blt.n	c22 <main+0x12>
			if(!button_pressed){
 c4c:	4b13      	ldr	r3, [pc, #76]	; (c9c <main+0x8c>)
 c4e:	7d1b      	ldrb	r3, [r3, #20]
 c50:	2b00      	cmp	r3, #0
 c52:	d1e9      	bne.n	c28 <main+0x18>
				button_pressed = true;
 c54:	4d11      	ldr	r5, [pc, #68]	; (c9c <main+0x8c>)
 c56:	2301      	movs	r3, #1
 c58:	752b      	strb	r3, [r5, #20]
				timer_stop(&TIMER_0);
 c5a:	4c14      	ldr	r4, [pc, #80]	; (cac <main+0x9c>)
 c5c:	4620      	mov	r0, r4
 c5e:	4b14      	ldr	r3, [pc, #80]	; (cb0 <main+0xa0>)
 c60:	4798      	blx	r3
				timer_remove_task(&TIMER_0, &TIMER_0_task1);
 c62:	4629      	mov	r1, r5
 c64:	4620      	mov	r0, r4
 c66:	4b13      	ldr	r3, [pc, #76]	; (cb4 <main+0xa4>)
 c68:	4798      	blx	r3
				configure_timer(TIMER_INTERVAL_FAST);
 c6a:	2064      	movs	r0, #100	; 0x64
 c6c:	4b0a      	ldr	r3, [pc, #40]	; (c98 <main+0x88>)
 c6e:	4798      	blx	r3
 c70:	e7da      	b.n	c28 <main+0x18>
				button_pressed = false;
 c72:	4d0a      	ldr	r5, [pc, #40]	; (c9c <main+0x8c>)
 c74:	2300      	movs	r3, #0
 c76:	752b      	strb	r3, [r5, #20]
				timer_stop(&TIMER_0);
 c78:	4c0c      	ldr	r4, [pc, #48]	; (cac <main+0x9c>)
 c7a:	4620      	mov	r0, r4
 c7c:	4b0c      	ldr	r3, [pc, #48]	; (cb0 <main+0xa0>)
 c7e:	4798      	blx	r3
				timer_remove_task(&TIMER_0, &TIMER_0_task1);
 c80:	4629      	mov	r1, r5
 c82:	4620      	mov	r0, r4
 c84:	4b0b      	ldr	r3, [pc, #44]	; (cb4 <main+0xa4>)
 c86:	4798      	blx	r3
				configure_timer(TIMER_INTERVAL_SLOW);
 c88:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 c8c:	4b02      	ldr	r3, [pc, #8]	; (c98 <main+0x88>)
 c8e:	4798      	blx	r3
 c90:	e7ca      	b.n	c28 <main+0x18>
 c92:	bf00      	nop
 c94:	000002d1 	.word	0x000002d1
 c98:	00000bdd 	.word	0x00000bdd
 c9c:	20000024 	.word	0x20000024
 ca0:	00000435 	.word	0x00000435
 ca4:	41008000 	.word	0x41008000
 ca8:	00000443 	.word	0x00000443
 cac:	2000003c 	.word	0x2000003c
 cb0:	00000599 	.word	0x00000599
 cb4:	00000681 	.word	0x00000681

00000cb8 <__libc_init_array>:
 cb8:	b570      	push	{r4, r5, r6, lr}
 cba:	4e0d      	ldr	r6, [pc, #52]	; (cf0 <__libc_init_array+0x38>)
 cbc:	4c0d      	ldr	r4, [pc, #52]	; (cf4 <__libc_init_array+0x3c>)
 cbe:	1ba4      	subs	r4, r4, r6
 cc0:	10a4      	asrs	r4, r4, #2
 cc2:	2500      	movs	r5, #0
 cc4:	42a5      	cmp	r5, r4
 cc6:	d109      	bne.n	cdc <__libc_init_array+0x24>
 cc8:	4e0b      	ldr	r6, [pc, #44]	; (cf8 <__libc_init_array+0x40>)
 cca:	4c0c      	ldr	r4, [pc, #48]	; (cfc <__libc_init_array+0x44>)
 ccc:	f000 f858 	bl	d80 <_init>
 cd0:	1ba4      	subs	r4, r4, r6
 cd2:	10a4      	asrs	r4, r4, #2
 cd4:	2500      	movs	r5, #0
 cd6:	42a5      	cmp	r5, r4
 cd8:	d105      	bne.n	ce6 <__libc_init_array+0x2e>
 cda:	bd70      	pop	{r4, r5, r6, pc}
 cdc:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 ce0:	4798      	blx	r3
 ce2:	3501      	adds	r5, #1
 ce4:	e7ee      	b.n	cc4 <__libc_init_array+0xc>
 ce6:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 cea:	4798      	blx	r3
 cec:	3501      	adds	r5, #1
 cee:	e7f2      	b.n	cd6 <__libc_init_array+0x1e>
 cf0:	00000d8c 	.word	0x00000d8c
 cf4:	00000d8c 	.word	0x00000d8c
 cf8:	00000d8c 	.word	0x00000d8c
 cfc:	00000d90 	.word	0x00000d90
 d00:	682f2e2e 	.word	0x682f2e2e
 d04:	732f6c61 	.word	0x732f6c61
 d08:	682f6372 	.word	0x682f6372
 d0c:	745f6c61 	.word	0x745f6c61
 d10:	72656d69 	.word	0x72656d69
 d14:	0000632e 	.word	0x0000632e
 d18:	682f2e2e 	.word	0x682f2e2e
 d1c:	752f6c61 	.word	0x752f6c61
 d20:	736c6974 	.word	0x736c6974
 d24:	6372732f 	.word	0x6372732f
 d28:	6974752f 	.word	0x6974752f
 d2c:	6c5f736c 	.word	0x6c5f736c
 d30:	2e747369 	.word	0x2e747369
 d34:	00000063 	.word	0x00000063
 d38:	40003800 	.word	0x40003800
 d3c:	40003c00 	.word	0x40003c00
 d40:	4101a000 	.word	0x4101a000
 d44:	4101c000 	.word	0x4101c000
 d48:	42001400 	.word	0x42001400
 d4c:	42001800 	.word	0x42001800
 d50:	43001400 	.word	0x43001400
 d54:	43001800 	.word	0x43001800

00000d58 <_tcs>:
 d58:	006c0001 00000308 00000000 000005dc     ..l.............
 d68:	00000000 682f2e2e 742f6c70 70682f63     ....../hpl/tc/hp
 d78:	63745f6c 0000632e                       l_tc.c..

00000d80 <_init>:
 d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 d82:	bf00      	nop
 d84:	bcf8      	pop	{r3, r4, r5, r6, r7}
 d86:	bc08      	pop	{r3}
 d88:	469e      	mov	lr, r3
 d8a:	4770      	bx	lr

00000d8c <__init_array_start>:
 d8c:	00000289 	.word	0x00000289

00000d90 <_fini>:
 d90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 d92:	bf00      	nop
 d94:	bcf8      	pop	{r3, r4, r5, r6, r7}
 d96:	bc08      	pop	{r3}
 d98:	469e      	mov	lr, r3
 d9a:	4770      	bx	lr

00000d9c <__fini_array_start>:
 d9c:	00000265 	.word	0x00000265
